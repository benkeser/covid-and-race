#' a function to map a fitted model into posterior samples of paf & attr cases
#' @param which_variable a string indicating which (collection of) variable(s)
#' for which you want to obtain a PAF
#' @param post_samps list of posterior samples as generated by 
#' \code{posterior_samples} function in 02_posteriorsampling.R
#' @param dat the data set used to fit the models (needed to compute reference values)
#' @param mod the fitted model
#' @param pct_black_thresholds vector to cut percent black for plots
#' @return a data.frame with posterior mean and 95% credible interval for 
#' paf in all counties and stratified by proportion black as defined by pct_black_thresholds.
#' names should be self-explanatory

get_paf_posteriors <- function(which_variable, post_samps, dat, mod,
                               pct_black_thresholds = c(13)){
  n_draws <- length(post_samps$zero_prob)

  # get predicted value under observed level of exposure
  state_mod_mat <- model.matrix(~ -1 + factor(id), data = dat)

  # if spatial errors are used, there are two random effects for
  # each state
  if(mod$model.random == "BYM2 model"){
    state_mod_mat <- cbind(state_mod_mat, state_mod_mat)
  }

  obs_mod_mat <- cbind(log(dat$population), state_mod_mat, mod$model.matrix)

  # get predicted value under set level of exposure
  # level to set exposure to 
  e <- sapply(which_variable, function(wv){
    quantile(dat[[wv]], p = 0.25, na.rm = TRUE)
  })

  pred_mod_mat <- as.matrix(obs_mod_mat)
  ct <- 0
  for(wv in which_variable){
    ct <- ct + 1
    # only set for counties < e
    in_lower_quant <- pred_mod_mat[,wv] < e[ct]
    pred_mod_mat[!in_lower_quant, wv] <- e[ct]
  }

  # # first confirm you can get predicted values to match up
  # id <- 2
  # beta_draw <- matrix(c(1,post_samps$random_effects[id,], post_samps$fixed_effects[id,]), 
  #                     ncol = 1)
  # lin_pred <- as.numeric(mod_mat %*% beta_draw)
  # pi_samp <- post_samps$zero_prob[id]
  # alpha_samp <- post_samps$size_param[id]
  # # check_me <- (1 - pi_samp) * ((1 - pi_samp) * exp(lin_pred) / (1 - (1 + alpha_samp * (1 - pi_samp) * exp(lin_pred))^(-1/alpha_samp)))
  # check_me <- (1 - pi_samp)*exp(lin_pred)

  # head(exp(post_samps$predicted[id,]))
  # head(check_me)
  # close, differences due to sampling of zero prob
  obs_samps <- sapply(seq_len(n_draws), function(id){
    beta_draw <- matrix(c(1,post_samps$random_effects[id,], post_samps$fixed_effects[id,]), 
                        ncol = 1)
    check_me <- (1 - post_samps$zero_prob[id]) * exp(as.numeric(obs_mod_mat %*% beta_draw))
    return(check_me)
  })

  pred_samps <- sapply(seq_len(n_draws), function(id){
    beta_draw <- matrix(c(1,post_samps$random_effects[id,], post_samps$fixed_effects[id,]), 
                        ncol = 1)
    check_me <- (1 - post_samps$zero_prob[id]) * exp(as.numeric(pred_mod_mat %*% beta_draw))
    return(check_me)
  })

  get_paf <- function(obs_samps, pred_samps, strat_lvl_low, strat_lvl_high){
    strat_idx <- dat$percentblack < strat_lvl_high & dat$percentblack >= strat_lvl_low
    num_samples_strat <- colSums(obs_samps[strat_idx,] - pred_samps[strat_idx,])
    denom_samples_strat <- colSums(obs_samps[strat_idx,])
    paf_samples_strat <- num_samples_strat/denom_samples_strat
    post_mean_paf_strat <- mean(paf_samples_strat)
    ci_paf_strat <- quantile(paf_samples_strat, c(0.025, 0.975))
    post_mean_attr_cases_strat <- median(num_samples_strat)
    ci_attr_cases_strat <- quantile(num_samples_strat, c(0.025, 0.975))
    return(c(post_mean_paf_strat, ci_paf_strat, 
             post_mean_attr_cases_strat, ci_attr_cases_strat))
  }

  pct_black_thresholds <- c(-Inf, pct_black_thresholds, Inf)
  tmp <- get_paf(obs_samps = obs_samps, pred_samps = pred_samps, 
                 strat_lvl_low = -Inf, strat_lvl_high = Inf)
  for(ct in 2:(length(pct_black_thresholds))){
    tmp <- rbind(tmp, get_paf(obs_samps = obs_samps, pred_samps = pred_samps, 
                              strat_lvl_low = pct_black_thresholds[ct-1], strat_lvl_high = pct_black_thresholds[ct]))
  }
  
  out <- data.frame(tmp)
  colnames(out) <- c("PAF", "paf_cil", "paf_ciu",
                     "attr_cases", "attr_cases_cil", "attr_cases_ciu")

  tmp <- NULL
  for(ct in 2:(length(pct_black_thresholds))){
    if(ct == 2){
      tmp <- c(tmp, paste0("Proportion black < ", pct_black_thresholds[ct], "%"))
    }else if(ct == length(pct_black_thresholds)){
      tmp <- c(tmp, paste0("Proportion black >", pct_black_thresholds[ct-1], "%"))
    }else{
      tmp <- c(tmp, paste0("Proportion black ", pct_black_thresholds[ct-1], "% - ", pct_black_thresholds[ct], "%"))
    }
  }
  out$counties <- c("All", tmp)

  return(out)
}

#' function to generate a data frame used for PAF plotting. extracts variable names
#' from fitted model; calls get_paf_posteriors to get summaries of PAF posterior 
#' distributions for modifiable risk factors (others are removed as specified by 
#' dont_plot option); and formats a data.frame that is needed for generating PAF plot.
#' @param post_samps list of posterior samples as generated by 
#' \code{posterior_samples} function in 02_posteriorsampling.R
#' @param dat the data set used to fit the models (needed to compute reference values)
#' @param mod the fitted model
#' @param dont_plot variables that should not be included in the plot
get_paf_plot_data <- function(post_samps, dat, mod, 
                              dont_plot = c("percentblack",
                                            "percentwhite",
                                            "percentover65",
                                            "urbanicity2013",
                                            "time_since_first_case"),
                              pct_black_thresholds = pct_black_thresholds){

  # get names of variables to plot
  fixed_eff_names <- colnames(post_samps$fixed_effects)
  all_variables_in_model <- gsub(":1", "", fixed_eff_names[-1])
  variables_to_plot <- all_variables_in_model[!(all_variables_in_model %in% dont_plot)]

  # pafs for individual variables
  paf_1var <- sapply(variables_to_plot, get_paf_posteriors, 
                     post_samps = post_samps, dat = dat, mod = mod,
                     pct_black_thresholds = pct_black_thresholds)
  paf_allvar <- get_paf_posteriors(post_samps = post_samps,
                                   dat = dat, mod = mod,
                                   which_variable = variables_to_plot,
                                   pct_black_thresholds = pct_black_thresholds)
  tmp <- apply(paf_1var, 2, function(x){
    data.frame(x)
  })
  rslt_df <- rbind(Reduce(rbind, tmp), paf_allvar)
  rslt_df$risk_factor <- c(rep(colnames(paf_1var), each = length(pct_black_thresholds) + 2), 
                           rep("All", length(pct_black_thresholds) + 2))
  rslt_df$risk_factor_label <- c(unlist(sapply(rslt_df$risk_factor, function(x){
    var_label(dat[[x]])
  }), use.names = FALSE), rep("All", length(pct_black_thresholds) + 2)) 
  # rslt_df$risk_factor_label[rslt_df$risk_factor == "All"] <- "All"
  # rearrange
  return(rslt_df)
}

#' make a plot of PAF for subset of variables and include numbers 
#' of attributable cases
#' @param post_samps samples from posterior of fitted model 
#' @param dat the data used to fit the model
#' @param mod the fitted model
#' @param dont_plot the variables that were included in the model
#' that should be excluded from the plot (because they are not 
#' modifiable)
#' @param order_of_risk_factors must explicitly state the order
#' from top to bottom of risk factors that appear on the plot.
#' breaks if does not include all risk factors in model
#' @param paf_limits plotting limits for paf axis
#' @return a ggplot object of the plot
#' 
make_paf_plot <- function(paf_plot_data, dat,
                          dont_plot = c("percentblack",
                                        "percentwhite",
                                        "percentover65",
                                        "urbanicity2013",
                                        "time_since_first_case"),
                          order_of_risk_factors = c("All",
                                                    "HIVrate",
                                                    "heartdiseasedeathrate",
                                                    "cerebroandhypertensiondeathrate",
                                                    "percdiabetes",
                                                    "pctunemployed",
                                                    "pctuninsured",
                                                    "pm25",
                                                    "peroccgreaterthan1",
                                                    "socialdistance"),
                          pct_black_thresholds = c(13), 
                          paf_limits = c(-0.55, 0.55)){

  # change level of risk factors to get desired order
  # reorder_vals <- order(-sapply(order_of_risk_factors, function(i){
  #   which(paf_plot_data$risk_factor == i)[1]
  # }))
  label_order <- unlist(sapply(order_of_risk_factors, function(i){
    var_label(dat[[i]])
  }),use.names = FALSE)
  label_order <- rev(c("All", label_order))

  paf_plot_data$`Risk Factor` <- factor(paf_plot_data$risk_factor_label,
                                        levels = label_order)
  # change level of county
  paf_plot_data$counties <- factor(paf_plot_data$counties,
                                   levels = paf_plot_data$counties[(length(pct_black_thresholds) + 2):1])

  # format labels
  paf_plot_data$format_attr <- paste0(
    ifelse(paf_plot_data$attr_cases < 0, "", " "), 
    round(paf_plot_data$attr_cases), " (",
    round(paf_plot_data$attr_cases_cil), ", ",
    round(paf_plot_data$attr_cases_ciu), ")"
  )
  paf_plot_data$`PAF (95% CI)` <- paf_plot_data$PAF

  p <- ggplot(paf_plot_data, aes(x = `Risk Factor`, y = `PAF (95% CI)`, ymax = 1,
                                 colour = counties, group = counties,
                                 label = format_attr)) +
        geom_point(position = position_dodge(width = 0.75)) + 
        geom_errorbar(aes(ymin = paf_cil, ymax = paf_ciu), width = 0.125,
                      position = position_dodge(width = 0.75)) + 
        theme_bw() + 
        scale_color_nejm(breaks=rev(levels(paf_plot_data$counties))) + 
        coord_flip(ylim = paf_limits, clip = "off") + 
        geom_hline(yintercept = 0, linetype = "dashed") + 
        theme(legend.position = "bottom", legend.title = element_blank()) + 
        theme(plot.margin = unit(c(1,10,1,1), "lines")) + 
        geom_text(aes(group = counties),
                  # nudge_x = 0.5, 
                  position = position_dodge(width = 0.75),
                  y = 0.6, colour = "black",
                  # ymax = 1,
                  hjust = 0,
                  size = 3.5) + 
        annotate("text", label = 'underline("Attributable cases (95% CI)")',
                 parse = TRUE, y = 0.6, x = length(paf_plot_data[,1])/(length(pct_black_thresholds) + 2) + 0.5,
                 hjust = 0, size = 3.5)
  return(p)
}


#' make a bubble plot
#' @param dat the cleaned data set
#' @param deaths if TRUE deaths plotted on y axis; if FALSE cases plotted on y axis
make_bubble_plot <- function(dat, deaths = TRUE){
  if(deaths){
    bubble_plot <- ggplot(dat[dat$coviddeaths > 0,], aes(x = percentblack, 
                                          y = coviddeaths/population/time_since_first_case * 10e4, 
                                          size = population))
  }else{
    bubble_plot <- ggplot(dat[dat$covidcases > 0,], aes(x = percentblack, 
                                        y = coviddeaths/population/time_since_first_case * 10e4, 
                                        size = population))
  }
  
  bubble_plot <- bubble_plot + 
                  scale_y_log10() + 
                  geom_point(alpha=0.2, aes(text = paste0("County: ", county, "\n",
                                        "State: ", state, "\n",
                                        "Population: ", population, "\n",
                                        "COVID-19 cases: ", covidcases, "\n",
                                        "COVID-19 deaths: ", coviddeaths, "\n",
                                        "Days since detections: ", time_since_first_case))) + 
                  geom_smooth(method = 'loess', aes(color = "red"), show.legend = FALSE) + 
                  theme(legend.position = "none") +
                  xlab("Percent black") + ylab(paste0(ifelse(deaths, "Deaths ", "Cases "),
                                                      "per 100,000 per day since detection"))
  return(bubble_plot)                
}

